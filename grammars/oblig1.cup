package oblig1parser;
import java_cup.runtime.*;
import syntaxtree.*;
import java.util.*;

parser code {:

:};

/* Terminals */
terminal                        CLASS; 
terminal                        REFERENCE;
terminal                        PROCEDURE;
terminal                        VARIABLE;
terminal String                 FLOAT, INT, STRING, BOOL;
terminal 			                  LBRACK, RBRACK;
terminal                        LCHEV, LCHEVEQ, RCHEV, RCHEVEQ;
terminal                        EQUALS, NEQUAL;
terminal                        AND, OR, NOT;
terminal                        TRUE, FALSE;
terminal                        NULL;
terminal                        DOT;
terminal                        NEW;
terminal                        PLUS, MINUS, TIMES, DIVIDE, EXPO;
terminal 			                  LPAR, RPAR;
terminal                        SEMI, RETURN;
terminal			                  IF, THEN, ELSE, WHILE, DO;
terminal			                  RET;
terminal			                  COMMA;

terminal String                 ID;
terminal String                 STRING_LITERAL;
terminal String			            NAME;
terminal String                 INT_LITERAL;
terminal String                 FLOAT_LITERAL;
terminal String                 BOOL_LITERAL; /*?*/

/* Non terminals */
non terminal Program	          program;
non terminal Decl               decl;
non terminal List<Decl>         decl_list;
non terminal VarDecl            var_decl;
non terminal List<Decl>         var_list;
non terminal ProcDecl           proc_decl; 
non terminal String             proc_decl_type;
non terminal List<Decl>         proc_decl_decls;
non terminal ClassDecl          class_decl;
non terminal ParamDecl          param_decl;
non terminal List<Decl>         param_list;
non terminal Boolean            param_ref;

non terminal                    exp, exp1, exp2, exp3, exp4, exp5, exp6, exp7;
non terminal                    var;
non terminal                    log_op;
non terminal                    rel_op;
non terminal                    arit_op;
non terminal                    literal;
non terminal                    actual_param;
non terminal String             type;


/* The grammar */
program			            ::= decl_list:dl
                          {: RESULT = new Program(dl); :} 
				                ;

decl_list               ::= decl:d {: List<Decl> l = new LinkedList<Decl>();
                            l.add(d);
                            RESULT = l; :} 
                          | decl_list:dl decl:d 
                            {: dl.add(d); RESULT = dl; :}
                        ;

decl                    ::= class_decl:sd {: RESULT = sd; :}
                          | proc_decl:pd {:RESULT = pd; :} 
                          | var_decl:vd {: RESULT = vd; :}
                        ;
                        

var_decl                ::= VARIABLE type:t ID:name SEMI
                          {: RESULT = new VarDecl(name, t); :} 
                        ;

var_list                ::= decl_list:l {: RESULT = l; :}
                          | {: RESULT = null; :}
                        ; 

proc_decl               ::= PROCEDURE proc_decl_type:t ID:n
                            LPAR param_list:pl RPAR
                            LBRACK proc_decl_decls RBRACK
                            
                            {: RESULT = new ProcDecl(n, t, pl, null); :}
                        ; 

proc_decl_decls         ::= decl_list:dl {:RESULT = dl; :}
                            | {:RESULT = null; :}
                        ;

proc_decl_type          ::= RET type:t {: RESULT = t; :}
                            | {: RESULT = null; :}
                        ;
                        
class_decl		          ::= CLASS ID:name LBRACK var_list:v RBRACK
                          {: RESULT = new ClassDecl(name, v); :}
				                ;

param_decl              ::= param_ref:ref type:t ID:name {: RESULT = new ParamDecl(name, t, ref); :}
                            | {:RESULT = null; :}
                        ;
                        
param_ref               ::= REFERENCE {: RESULT = true; :}
                            | {:RESULT = false; :}
                        ;

param_list              ::= param_decl:p {: List<Decl> l = new LinkedList<Decl>();
                            l.add(p);
                            RESULT = l; :} 
                          | param_list:pl COMMA param_decl:p 
                            {: pl.add(p); RESULT = pl; :}
                        ;


exp		                  ::= exp OR exp1 | exp1;

exp1		                ::= exp1 AND exp2 | exp2;

exp2		                ::= NOT exp2 | exp3;

exp3		                ::= exp3 rel_op exp4;

exp4		                ::= exp4 PLUS exp5 | exp4 MINUS exp5 | exp5; 

exp5		                ::= exp5 TIMES exp6 | exp5 DIVIDE exp6 | exp6;

exp6		                ::= exp7 EXPO exp6 | exp7;

exp7		                ::= var | exp | NEW NAME | literal | LPAR exp RPAR;



/*
exp                     ::= exp log_op exp
                            | NOT exp
                            | exp rel_op exp
                            | exp arit_op exp
                            | LPAR exp RPAR
                            | literal */
                            /* | call_stmt */
/*                            | NEW ID:name
                            | var
                        ;*/

var                     ::= ID:name | exp DOT ID:name;

log_op                  ::= AND | OR;
rel_op                  ::= LCHEV | LCHEVEQ | RCHEV | RCHEVEQ | EQUALS | NEQUAL;
arit_op                 ::= PLUS | MINUS | TIMES | DIVIDE | EXPO;

literal                 ::= FLOAT_LITERAL | INT_LITERAL | STRING_LITERAL 
                            | TRUE | FALSE | NULL;

actual_param            ::= REFERENCE var | exp;

type                    ::= FLOAT     {: RESULT = "float";  :}
                            | INT     {: RESULT = "int";    :}
                            | STRING  {: RESULT = "string"; :} 
                            | BOOL    {: RESULT = "bool";   :}
                            | ID:name {: RESULT = name;     :}
                        ;

